#!/usr/bin/with-contenv bash
# shellcheck shell=bash

# This script monitors qBittorrent for removed torrents and deletes orphan .ftag files
# Adapted from https://github.com/t-anc/GSP-Qbittorent-Gluetun-sync-port-mod/blob/main/root/etc/s6-overlay/s6-rc.d/svc-mod-gluetun-sync-port/run

# Configuration Variables
MAX_SLEEP_TIME="${FTAG_SLEEP:-15}"   # Maximum sleep interval
RETRY_DELAY="${FTAG_RETRY_DELAY:-10}"  # Retry delay on errors
INIT_RETRY_WAIT="${FTAG_INIT_RETRY_WAIT:-10}"  # Initial retry wait time
DEBUG="${DOCKER_MODS_DEBUG:-false}"

QBITTORRENT="${FTAG_QBT_ADDR:-http://localhost:${WEBUI_PORT:-8080}}"
[ -n "${FTAG_QBT_PASSWORD_FILE}" ] && FTAG_QBT_PASSWORD="$(cat "${FTAG_QBT_PASSWORD_FILE}")"
QBT_USERNAME="${FTAG_QBT_USERNAME}"
QBT_PASSWORD="${FTAG_QBT_PASSWORD}"
QBT_COOKIES="--cookie-jar /tmp/cookies.txt --cookie /tmp/cookies.txt"
[ "${FTAG_CERT_CHECK,,}" = 'false' ] && CURL_OPT='--insecure'
CONF_FILE='/config/qBittorrent/qBittorrent.conf'

RID_FILE="/tmp/qbittorrent_rid"  # Store the last response ID

# Functions
log() {
    echo "[mod-freezetag] ${1} >&2"
}
log_debug() {
    if [ "${DEBUG,,}" = 'true' ]; then
        echo "[mod-freezetag] (DEBUG) ${1} >&2"
    fi
}


qbt_login() {
    curl --fail --silent \
        ${CURL_OPT} \
        ${QBT_COOKIES} \
        --url "${QBITTORRENT}/api/v2/auth/login" \
        --data "username=${QBT_USERNAME}" \
        --data "password=${QBT_PASSWORD}"
}

init_checks(){
  # Enable or not init_checks
  if [ "${FTAG_SKIP_INIT_CHECKS,,}" = 'true' ]; then
    return 0
  fi

  # Check 1 : 
  #   In case of HTTPS, check if qBittorrent is using a trusted certificate.

  if echo "${QBITTORRENT}" | grep -iq 'https://' ;then
    curl ${CURL_OPT} --silent --output /dev/null "${QBITTORRENT}"
    if [ "$?" -eq '60' ]; then
      err='true'
      log "Warning: Your qBittorrent certificate is untrusted. See HTTPS section in https://github.com/t-anc/GSP-Qbittorent-Gluetun-sync-port-mod#troubleshooting."
    fi
  fi

  # Check 2 : 
  #   Check for the auth bypass in qbittorrent's config file,
  #   or check for bad credentials.

  if [ ! -f "${CONF_FILE}" ]; then
    log "WARNING: ${CONF_FILE} not found, can't check the The \"Bypass authentication for clients on localhost\" setting. Running in standalone mode."
  else
    if { [ -z "${QBT_USERNAME}" ] || [ -z "${QBT_PASSWORD}" ] ;} && [ "$(grep 'LocalHostAuth' ${CONF_FILE} | awk -F'=' '{print $2}')" != "false" ]; then
      err='true'
      log "Warning: The \"Bypass authentication for clients on localhost\" setting is not set."
    elif [ -n "${QBT_USERNAME}" ] && [ -n "${QBT_PASSWORD}" ] && [ "$(qbt_login)" != "Ok." ]; then
        err='true'
        log "Error: Qbittorrent authentication failed, check the credentials."
    fi
  fi

  # Check 3 :
  #   Check for "Host header validation".
  if [ "$(curl ${CURL_OPT} --write-out '%{http_code}' --silent --output /dev/null "${QBITTORRENT}")" -eq 401 ]; then
    err='true'
    log "Error: Qbittorrent returned 401. Is the \"Enable Host header validation\" setting set ? Is $(basename "${QBITTORRENT%:*}") whitelisted ?"
  fi


  # Display Check results.
  # In case of failed checks, enter an empty loop : 
  #   -> exiting the script would make s6-overlay to re-run it.
  if [ -n "${err}" ];then
    log "Error: Init checks failed, exiting the mod. You can disable init checks by setting \"FTAG_SKIP_INIT_CHECKS=true\"."
    while :; do
      sleep 3600
    done
  else
    log "Init checks passed."
  fi
}

fetch_sync_data() {
    local rid=$1
    local response
    local new_rid
    local torrents_removed
    local nocache=$(date +%s%N)  # Generate a timestamp-based nocache value

    log_debug "Fetching /sync/maindata with RID: $rid"
    log "Sending request to ${QBITTORRENT}/api/v2/sync/maindata?rid=${rid}&nocache=${nocache}"

    # Fetch data
    response=$(curl --silent --fail --get \
        ${QBT_COOKIES} \
        --url "${QBITTORRENT}/api/v2/sync/maindata?rid=${rid}&nocache=${nocache}" 2>/dev/null)

    # Check if curl failed
    if [[ $? -ne 0 || -z "$response" ]]; then
        log "ERROR: Failed to fetch data from /sync/maindata."
        log_debug "Curl response was empty or failed. Response: $response"
        return 1
    fi

    # Log the raw response for debugging
    log_debug "Raw response from /sync/maindata: $response"

    # Parse new RID
    new_rid=$(echo "$response" | jq -r '.rid')
    if [[ -z "$new_rid" ]]; then
        log "ERROR: Failed to parse RID from response."
        return 1
    fi
    echo "$new_rid" > "$RID_FILE"
    log_debug "$(date +"%Y-%m-%d %H:%M:%S") Parsed new RID: $new_rid"


    # Parse removed torrents
    torrents_removed=$(echo "$response" | jq -c '.torrents_removed[]?')
    log_debug "Parsed removed torrents: $torrents_removed"

    # Handle removed torrents
    if [[ -n "$torrents_removed" ]]; then
        for torrent_hash in $torrents_removed; do
            torrent_hash=$(echo "$torrent_hash" | tr -d '"')
            log_debug "Processing removed torrent: $torrent_hash"
            # Uncomment the following line to call your handler function
            # handle_removed_torrent "$torrent_hash"
        done
    else
        log_debug "No removed torrents detected."
    fi

    log_debug "Done processing sync data. Next try in $MAX_SLEEP_TIME seconds."
    echo $new_rid
}


# handle_removed_torrent() {
#     local torrent_hash=$1
#     log "Handling removed torrent: $torrent_hash"

#     # Find and delete orphan .ftag files and their directories
#     local ftag_file=$(find /tracked_dir -name "${torrent_hash}.ftag" 2>/dev/null)
#     if [[ -n "$ftag_file" ]]; then
#         log "Found orphan .ftag file: $ftag_file. Deleting..."
#         rm -f "$ftag_file"
#         local parent_dir=$(dirname "$ftag_file")
#         if [[ -z "$(ls -A "$parent_dir")" ]]; then
#             log "Directory $parent_dir is empty. Deleting..."
#             rmdir "$parent_dir"
#         fi
#     else
#         log "No orphan .ftag file found for torrent hash: $torrent_hash."
#     fi
# }

init_checks

rid=0

if [[ -f "$RID_FILE" ]]; then
    rid=$(cat "$RID_FILE")
    log_debug "Debug: Read RID from file: $rid"  # Add this line to check the value from the file
else
    log_debug "Debug: RID file not found, using default RID=0"
fi

log_debug "Starting torrent removal tracker with RID=$rid"

while :; do
    log_debug "Debug: Calling fetch_sync_data with RID=$rid"  # Debugging the call
    rid=$(fetch_sync_data $rid)
    sleep "${MAX_SLEEP_TIME}"
done
