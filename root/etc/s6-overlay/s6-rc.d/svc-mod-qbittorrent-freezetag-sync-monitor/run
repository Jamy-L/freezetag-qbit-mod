#!/usr/bin/with-contenv bash
# shellcheck shell=bash

# This script monitors qBittorrent for removed torrents and deletes orphan .ftag files
# Adapted from https://github.com/t-anc/GSP-Qbittorent-Gluetun-sync-port-mod/blob/main/root/etc/s6-overlay/s6-rc.d/svc-mod-gluetun-sync-port/run

# Configuration Variables
MAX_SLEEP_TIME="${FTAG_SLEEP:-15}"   # Maximum sleep interval
RETRY_DELAY="${FTAG_RETRY_DELAY:-10}"  # Retry delay on errors
INIT_RETRY_WAIT="${FTAG_INIT_RETRY_WAIT:-10}"  # Initial retry wait time
DEBUG="${DOCKER_MODS_DEBUG:-false}"

QBITTORRENT="${FTAG_QBT_ADDR:-http://localhost:${WEBUI_PORT:-8080}}"
[ -n "${FTAG_QBT_PASSWORD_FILE}" ] && FTAG_QBT_PASSWORD="$(cat "${FTAG_QBT_PASSWORD_FILE}")"
QBT_USERNAME="${FTAG_QBT_USERNAME}"
QBT_PASSWORD="${FTAG_QBT_PASSWORD}"
QBT_COOKIES="--cookie-jar /tmp/cookies.txt --cookie /tmp/cookies.txt"
[ "${FTAG_CERT_CHECK,,}" = 'false' ] && CURL_OPT='--insecure'
CONF_FILE='/config/qBittorrent/qBittorrent.conf'
CATEGORY="${FTAG_CATEGORY:-}"

RESPONSE_FILE="/tmp/qbittorrent_rid"  # Store the last response ID

# Functions
log() {
    echo "[mod-freezetag] ${1}" >&2
}
log_debug() {
    if [ "${DEBUG,,}" = 'true' ]; then
        echo "[mod-freezetag] (Debug) ${1}" >&2
    fi
}


qbt_login() {
    curl --fail --silent \
        ${CURL_OPT} \
        ${QBT_COOKIES} \
        --url "${QBITTORRENT}/api/v2/auth/login" \
        --data "username=${QBT_USERNAME}" \
        --data "password=${QBT_PASSWORD}"
}

init_checks(){
  # Enable or not init_checks
  if [ "${FTAG_SKIP_INIT_CHECKS,,}" = 'true' ]; then
    return 0
  fi

  # Check 1 : 
  #   In case of HTTPS, check if qBittorrent is using a trusted certificate.

  if echo "${QBITTORRENT}" | grep -iq 'https://' ;then
    curl ${CURL_OPT} --silent --output /dev/null "${QBITTORRENT}"
    if [ "$?" -eq '60' ]; then
      err='true'
      log "Warning: Your qBittorrent certificate is untrusted. See HTTPS section in https://github.com/t-anc/GSP-Qbittorent-Gluetun-sync-port-mod#troubleshooting."
    fi
  fi

  # Check 2 : 
  #   Check for the auth bypass in qbittorrent's config file,
  #   or check for bad credentials.

  if [ ! -f "${CONF_FILE}" ]; then
    log "WARNING: ${CONF_FILE} not found, can't check the The \"Bypass authentication for clients on localhost\" setting. Running in standalone mode."
  else
    if { [ -z "${QBT_USERNAME}" ] || [ -z "${QBT_PASSWORD}" ] ;} && [ "$(grep 'LocalHostAuth' ${CONF_FILE} | awk -F'=' '{print $2}')" != "false" ]; then
      err='true'
      log "Warning: The \"Bypass authentication for clients on localhost\" setting is not set."
    elif [ -n "${QBT_USERNAME}" ] && [ -n "${QBT_PASSWORD}" ] && [ "$(qbt_login)" != "Ok." ]; then
        err='true'
        log "Error: Qbittorrent authentication failed, check the credentials."
    fi
  fi

  # Check 3 :
  #   Check for "Host header validation".
  if [ "$(curl ${CURL_OPT} --write-out '%{http_code}' --silent --output /dev/null "${QBITTORRENT}")" -eq 401 ]; then
    err='true'
    log "Error: Qbittorrent returned 401. Is the \"Enable Host header validation\" setting set ? Is $(basename "${QBITTORRENT%:*}") whitelisted ?"
  fi


  # Display Check results.
  # In case of failed checks, enter an empty loop : 
  #   -> exiting the script would make s6-overlay to re-run it.
  if [ -n "${err}" ];then
    log "Error: Init checks failed, exiting the mod. You can disable init checks by setting \"FTAG_SKIP_INIT_CHECKS=true\"."
    while :; do
      sleep 3600
    done
  else
    log "Init checks passed."
  fi
}

update_combined_data() {
    local full_list=$1
    local rid=$2

    # Construct the JSON structure
    local combined=$(jq -n --argjson torrents "$full_list" --arg rid "$rid" \
        '{rid:($rid | tonumber),torrents:$torrents}')
    
    # Save the combined structure to a file
    echo "$combined" > "$RESPONSE_FILE"
    
    # Return the combined JSON
    echo "$combined"
}

fetch_full_torrent_list() {
    local response=$(curl --silent --fail \
        ${CURL_OPT} \
        ${QBT_COOKIES} \
        --url "${QBITTORRENT}/api/v2/torrents/info?category=${CATEGORY}" 2>/dev/null)

    if [[ $? -ne 0 || -z "$response" ]]; then
        log "ERROR: Failed to fetch full torrent list for category: $CATEGORY."
        return 1
    fi

    # Use jq to transform the list into a dictionary mapping each hash to its torrent details
    response=$(echo "$response" | jq -c 'reduce .[] as $item ({}; .[$item.hash] = $item)')
    
    echo "$response"
}

fetch_sync_data() {
    local rid=$1
    local nocache=$(date +%s%N)

    log_debug "Fetching /sync/maindata with RID: $rid"
    local response=$(curl --silent --fail \
        ${CURL_OPT} \
        ${QBT_COOKIES} \
        --url "${QBITTORRENT}/api/v2/sync/maindata?rid=${rid}&nocache=${nocache}" 2>/dev/null)

    if [[ $? -ne 0 || -z "$response" ]]; then
        log "ERROR: Failed to fetch sync data from /sync/maindata."
        return 1
    fi

    log_debug "Sync data response: $response"
    echo "$response"
}

process_removed_torrents() {
    local sync_response=$1
    local torrent_list=$2

    local torrents_removed=$(echo "$sync_response" | jq -c '.torrents_removed[]?')

    if [[ -n "$torrents_removed" ]]; then
        for torrent_hash in $torrents_removed; do
            torrent_hash=$(echo "$torrent_hash" | tr -d '"')

            # Find the removed torrent in the full list
            local torrent_data=$(echo "$combined_data" | jq --arg hash "$torrent_hash" \
                '.torrents[] | select(.hash == $hash)')
            
            if [[ -n "$torrent_data" ]]; then
                local save_path=$(echo "$torrent_data" | jq -r '.save_path')
                log_debug "Removed torrent: $torrent_hash"
                log_debug "Save Path: $save_path"
            else
                log_debug "No matching torrent in the $CATEGORY category found for hash: $torrent_hash"
            fi
        done
    else
        log_debug "No removed torrents detected."
    fi
}

check_removed_torrents() {
    local prev_response=$1
    local rid=$(echo "$prev_response" | jq -r '.rid')
    local sync_response
    local new_rid
    local new_response

    # Fetch sync data
    sync_response=$(fetch_sync_data "$rid")

    # Parse new RID
    new_rid=$(echo "$sync_response" | jq -r '.rid')
    if [[ -z "$new_rid" ]]; then
        log "ERROR: Failed to parse RID from response."
        return 1
    fi

    # Remove the .ftag for the removed torrents if applicable
    process_removed_torrents "$sync_response" "$prev_response"

    # Update response for next iteration
    new_response=$(fetch_full_torrent_list)
    new_response=$(update_combined_data "$new_response" "$new_rid")


    log_debug "Done processing sync data. Next try in $MAX_SLEEP_TIME seconds."
    echo $new_response
}

init_response() {
  if [[ -f "$RESPONSE_FILE" ]]; then
      response=$(cat "$RESPONSE_FILE")
      log_debug "Read RID from file."
  else
      log_debug "RID file not found, using default RID=0 with full torrent list fetch."
      response=$(fetch_full_torrent_list)
      response=$(update_combined_data "$response" "0")
  fi
  echo "$response"
}


init_checks


response=$(init_response)

while :; do
    response=$(check_removed_torrents "$response")
    log_debug "Full response after check_removed_torrents: $response"
    sleep "${MAX_SLEEP_TIME}"
done
